#!/usr/bin/env node

!function(e){var t={};function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=10)}([function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("es6-promisify")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("zlib")},function(e,t){e.exports=require("minimist")},function(e,t){e.exports=require("uuid/v4")},function(e,t){e.exports=require("csv")},function(e,t){e.exports=require("readline")},function(e,t){e.exports=require("columnify")},function(e,t,r){r(11),r(12),e.exports=r(15)},function(e,t){e.exports=require("core-js/stable")},function(e,t){e.exports=require("regenerator-runtime/runtime")},function(e,t){e.exports=require("colors")},function(e,t){e.exports=require("root-require")},function(e,t,r){"use strict";r.r(t);var n=r(5),a=r.n(n),i=r(0),s=r.n(i),o=r(3),c=r.n(o),u=r(1),l=r.n(u),d=r(6),f=r.n(d),p=r(2),h=r.n(p),y=r(4),w=r.n(y),m={filepath:process.env.NODE_HIDE_FILEPATH||process.env["win32"==process.platform?"USERPROFILE":"HOME"],filename:process.env.NODE_HIDE_FILENAME||"__node-hide-accounts",cryptography:{algorithm:process.env.CRYPT_ALGORITHM||"aes-256-ctr",password:process.env.CRYPT_SECRET}};const g=l()(s.a.readFile),b=l()(w.a.inflate),x=l()(w.a.deflate);function F(e={}){const t=e.algorithm||m.cryptography.algorithm,r=e.secret||m.cryptography.password;return{_algorithm:t,_secret:r,encrypt(e){const t=A(this._secret,this.getAlgorithmKeyLength()),{iv:r,key:n}=function(e){const t=h.a.randomBytes(16),r=e instanceof Buffer?e:Buffer.from(e);return{iv:t,key:r}}(t),a=h.a.createCipheriv(this._algorithm,n,r);let i=a.update(e,"utf8","hex");return`${i+=a.final("hex")}:${r.toString("hex")}`},async encryptFileUtf8(e){const t=await g(e,{encoding:"utf8"});return await this.encrypt(t)},decrypt(e){const[t,r]=e.split(":"),n=Buffer.from(r,"hex"),a=A(this._secret,this.getAlgorithmKeyLength()),i=a instanceof Buffer?a:Buffer.from(a),s=h.a.createDecipheriv(this._algorithm,i,n);let o=s.update(t,"hex","utf8");return o+=s.final("utf8")},async decryptFileUtf8(e){const t=await g(e,{encoding:"utf8"});return await this.decrypt(t)},stringToHash(e){const t=h.a.createHash("md5");return t.update(e),t.digest("hex")},fileToHash:async e=>await new Promise((t,r)=>{const n=h.a.createHash("md5"),a=s.a.ReadStream(e);a.on("data",e=>n.update(e)),a.on("error",r),a.on("end",()=>t(n.digest("hex")))}),async parseData(e,t=!0){switch(t){case!1:return await b(Buffer.from(e,"base64"));default:const r=await x(e);return Buffer.from(r).toString("base64")}},getAlgorithmKeyLength(){return{"des-ede3":24,aes128:16,"aes-128-cbc":16,aes192:24,aes256:32}[this._algorithm]},deprecated:{_algorithm:t,_secret:r,encrypt(e){const t=h.a.createCipher(this._algorithm,this._secret);let r=t.update(e,"utf8","hex");return r+=t.final("hex")},async encryptFileUtf8(e){const t=await g(e,{encoding:"utf8"});return this.encrypt(t)},decrypt(e){const t=h.a.createDecipher(this._algorithm,this._secret);let r=t.update(e,"hex","utf8");return r+=t.final("utf8")},async decryptFileUtf8(e){const t=await g(e,{encoding:"utf8"});return this.decrypt(t)}}}}function A(e,t=32){return e.length<t?A(`${e}_${e}`,t):e.slice(0,t)}const S=l()(s.a.mkdir),v=l()(s.a.writeFile),E=l()(s.a.readFile),_=F();var O={filepath:c.a.join(m.filepath,m.filename),async upgradeFrom3To4(){if(this.doesDirectoryExist(m.filepath)&&this.doesFileExist(this.filepath)){const e=await E(this.filepath),t=await _.parseData(e.toString("utf8"),!1);if(1===t.toString("utf8").split(":").length){const e=JSON.parse(_.deprecated.decrypt(t.toString("utf8")));return await this.writeObjToFile(e),!0}}return!1},async getAndDecryptFlatFile(){if(this.doesDirectoryExist(m.filepath)){if(!this.doesFileExist(this.filepath))return await v(this.filepath,""),null;{const e=await E(this.filepath);if(0===e.length)return null;{const t=await _.parseData(e.toString("utf8"),!1);try{return JSON.parse(_.decrypt(t.toString("utf8")))}catch(e){throw`We're having a problem parsing your flat file at '${this.filepath}'.\n              This is likely due to a different master password, environment variable CRYPT_SECRET,\n              being used that previously was set. Make sure you have the correct\n              secret you used before and try again.`.replace(/\n\s+/g,"\n")}}}}return await S(m.filepath),await v(this.filepath,""),""},async writeObjToFile(e,t={}){const r=Object.assign(t,e),n=_.encrypt(JSON.stringify(r)),a=await _.parseData(n);return await v(this.filepath,a)},doesDirectoryExist(e){try{return s.a.statSync(e).isDirectory()}catch(e){return!1}},doesFileExist(e){try{return s.a.statSync(e).isFile()}catch(e){return!1}}},D={createUuid:()=>f()(),async addAccount(e,t,r,n=""){const a={[this.createUuid()]:{name:e,username:t||"",password:r||"",extra:n||""}},i=await O.getAndDecryptFlatFile();return await O.writeObjToFile(a,i||{})},async updateAccount(e,t={},r={}){const n={[e]:{name:t.name||r.name||"",username:t.username||r.username||"",password:t.password||r.password||"",extra:t.extra||r.extra||""}},a=await O.getAndDecryptFlatFile();return await O.writeObjToFile(n,a||{})},async deleteAccountByUuid(e){let t=await O.getAndDecryptFlatFile();return!(!t||!t[e])&&(delete t[e],await O.writeObjToFile({},t),!0)},async findAccountByUuid(e){const t=await O.getAndDecryptFlatFile();return!(!t||!t[e])&&Object.assign(t[e],{uuid:e})},async findAccountByName(e){const t=await O.getAndDecryptFlatFile();if(!t)return!1;const r=Object.keys(t).filter(r=>t[r].name.toLowerCase()==e.toLowerCase())[0];return!!r&&Object.assign(t[r],{uuid:r})},async searchForAccountsByName(e=null,t=null){return await this.searchForAccountsByField("name",e,t)},async searchForAccountsByUsername(e,t=null){return await this.searchForAccountsByField("username",e,t)},async searchForAccountsByField(e,t=null,r=null){if(!(r=r||await O.getAndDecryptFlatFile()))return{matches:[],total:0};const n=Object.keys(r),a=n.length;return{matches:n.map(n=>{const a=r[n];if(!a)return null;if(t){const r=new RegExp(t,"i");return a[e]&&r.test(a[e])?Object.assign(a,{uuid:n}):null}return Object.assign(a,{uuid:n})}).filter(e=>!!e),total:a}},sortByName:(e,t)=>e.name.toLowerCase()<t.name.toLowerCase()?-1:1},T=r(7),j=r.n(T),k={csv:e=>new Promise((t,r)=>{const n=j.a.parse({columns:!0},(e,n)=>{if(e)return r(e);t(n)});s.a.createReadStream(e).pipe(n)})},B=r(8),C=r.n(B);r(13);var $=r(9),N=r.n($);var q={noCryptSecret(){this.wrapInNewlines(()=>{console.log("You don't have environment variable CRYPT_SECRET set.".red),console.log(">export CRYPT_SECRET=[your all time master secret value]".green)})},listSingleAccount(e){this.wrapInNewlines(()=>console.log(this.columnify([e]).green))},listAccounts(e=[],t=0){const r=e.map(e=>"string"==typeof e?{name:e}:(delete e.password,e));this.wrapInNewlines(()=>{console.log("I found the following accounts:".blue),console.log(this.columnify(r).green),console.log(`${e.length} of ${t} total accounts returned`.blue)})},twoLinesDifferentColors(e,t,r="blue",n="green"){this.wrapInNewlines(()=>{e.length>0&&console.log(e[r]),t.length>0&&console.log(t[n])})},singleLine(e,t="blue",r=1){this.wrapInNewlines(()=>console.log(e[t]),r)},success(e,t=!0){let r=e=>e();t&&(r=this.wrapInNewlines),r(()=>console.log(e.green))},error(e){this.wrapInNewlines(()=>console.log(e.red))},wrapInNewlines(e=(()=>{}),t=1){const r=t-1>0?new Array(t-1).fill("\n").join(""):"";t>0&&console.log(r),e(),t>0&&console.log(r)},columnify:e=>N()(e,{minWidth:15})};const I=l()(s.a.writeFile),P=a()(process.argv.slice(2)),[L,R,U]=P._;m.cryptography.password||["file","version"].includes(L)||(q.noCryptSecret(),process.exit()),(async()=>{try{const e=P.e||P.extra,t=P.n||P.name,n=P.p||P.password,a=P.i||P.id||P.uuid,i=P.u||P.username,s=P.t||P.text,o=P.f||P.file,u=F(),l=c.a.join(m.filepath,m.filename);switch(L){case"file":q.twoLinesDifferentColors("Your encrypted file is in the following location:",l,"blue","green");break;case"version":q.success(r(14)("package.json").version,!1);break;case"add":const d=t||R;if(!d)return q.error("An account name (-n or --name) parameter is a required at a minimum to add a new account.");await D.addAccount(d,i,n,e),q.success(`Successfully added account '${d}'!`);break;case"delete":if(!a)return q.error("A uuid (-i or --id or --uuid) is a required to delete an account.");if(await D.deleteAccountByUuid(a))return q.success(`Successfully deleted account with uuid: '${a}'`);q.error(`We didn't find an account with uuid: '${a}'`);break;case"search":const f=P.s||P.search||R,p=await O.getAndDecryptFlatFile(),h=await D.searchForAccountsByName(f,p),y=await D.searchForAccountsByUsername(f,p),w={matches:[].concat(h.matches).concat(y.matches).sort(D.sortByName).reduce((e,t)=>(-1===e.indexOf(t)&&e.push(t),e),[]),total:h.total};q.listAccounts(w.matches,w.total);break;case"show":if(a){const e=await D.findAccountByUuid(a);return e?(n||delete e.password,q.listSingleAccount(e)):q.error(`We didn't find an account with uuid: ${a}`)}if(t||R){const e=t||R,r=await D.findAccountByName(e);return r?(n||delete r.password,q.listSingleAccount(r)):q.error(`We didn't find an account with name: ${e}`)}q.error("Either a name (-n or --name) or uuid (-i or --id or --uuid) parameter is a required at a minimum to show the details for an account.");break;case"update":if(a){const r=await D.findAccountByUuid(a);return r?(await D.updateAccount(a,{name:t,username:i,password:n,extra:e},r),q.success(`Successfully updated account with uuid: '${a}'!`)):q.error(`We didn't find an account with uuid: ${a}`)}if(t){const r=await D.findAccountByName(t);return r?(await D.updateAccount(r.uuid,{name:t,username:i,password:n,extra:e},r),q.success(`Successfully updated account with name: '${t}'!`)):q.error(`We didn't find an account with name: ${t}`)}q.error("Either a name (-n or --name) or uuid (-i or --id or --uuid) parameter is a required at a minimum to show the details for an account.");break;case"upgrade":if(await O.upgradeFrom3To4())return q.success("Successfully upgraded your flat file to work with version 4+ of hide!");q.success("Your local file has already been upgraded to support 4+ version of hide.");break;case"decryptfile":if("yes"===(await{rl:C.a.createInterface({input:process.stdin,output:process.stdout}),ask(e,t=!0){return new Promise((r,n)=>{this.rl.question(e,e=>{r(e),t&&this.close()})})},close(){this.rl.close()}}.ask("Are you sure you want to decrypt your file and save it to disk (yes/no): ")).toLowerCase()){const e=`${l}.json`,t=await O.getAndDecryptFlatFile();await I(e,JSON.stringify(t)),q.success(`Successfully saved your decrypted account data to:\n${e}`)}break;case"recrypt":const g=c.a.join(m.filepath,m.filename),b=F({secret:R}),x=await O.getAndDecryptFlatFile(),A=b.encrypt(JSON.stringify(x)),S=await b.parseData(A);await I(g,S),q.success(`Successfully updated your encrypted file with new secret to: ${g}`);break;case"import":const v=P.f||P.filepath||R;if(v&&O.doesFileExist(v)){let e=await k.csv(v),t=0,r=0;const n=e.length;for(;e.length>0;){const n=e.shift();n.name?(t++,await D.addAccount(n.name,n.username,n.password,n.extra)):r++}const a=`Successfully added ${t} accounts from CSV: ${v}!`,i=r>0?`Did not add ${r} accounts because we didn't see an account name ('name' CSV header).`:"";return q.twoLinesDifferentColors(a,i,"green","red"),q.singleLine(`Total number of rows in spreadsheet: ${n}\n`,"blue",0)}q.error(`We can't find filepath provided: ${v||"NO FILE PROVIDED"}`);break;case"encrypt":const E=s||R;let _;E?(_=u.encrypt(E),q.success(_)):o?(_=await u.encryptFileUtf8(o),q.success(_)):q.error("Please enter text (-t or --text) or a file path (-f or --file) to encrypt text.");break;case"decrypt":const T=s||R;let j;T?(j=u.decrypt(T),q.success(j)):o?(j=await u.decryptFileUtf8(o),q.success(j)):q.error("Please enter text (-t or --text) or a file path (-f or --file) to encrypt text.");break;default:q.error("I don't recognize what you are trying to do.\nPlease refer to the documentation for what commands I support.")}process.exit()}catch(e){"string"==typeof e?q.error(e):"TypeError: Bad input string"==e.toString()?(q.error(`Uh oh, The error we got is '${e.toString()}'\n\nThis usually means the CRYPT_SECRET is different for the info you're trying to decrypt than was used to encrypt it. Full stack trace below.`),console.log(e)):console.log(e),process.exit()}})()}]);